lazy val check = taskKey[Unit]("checks this plugin")

ThisBuild / version := "0.1"
ThisBuild / scalaVersion := "3.4.0"

lazy val root = (project in file("."))
  .enablePlugins(BuildInfoPlugin)
  .settings(
    name := "helloworld",
    buildInfoKeys := Seq(
      name,
      scalaVersion,
    ),
    buildInfoPackage := "hello",
    buildInfoOptions ++= Seq(
      BuildInfoOption.ToJson,
    ),
    homepage := Some(url("http://example.com")),
    licenses := Seq("MIT License" -> url("https://github.com/sbt/sbt-buildinfo/blob/master/LICENSE")),
    scalacOptions ++= Seq("-Xfatal-warnings"),
    check := {
      val f = (Compile / sourceManaged).value / "sbt-buildinfo" / ("%s.scala" format "BuildInfo")
      val lines = scala.io.Source.fromFile(f).getLines.toList
      val Expected = """// $COVERAGE-OFF$""" ::
        """package hello""" ::
        """""" ::
        """/** This object was generated by sbt-buildinfo. */""" ::
        """case object BuildInfo {""" ::
        """  /** The value is "helloworld". */""" ::
        """  val name: String = "helloworld"""" ::
        """  /** The value is "3.4.0". */""" ::
        """  val scalaVersion: String = "3.4.0"""" ::
        """  override val toString: String = {""" ::
        """    "name: %s, scalaVersion: %s".format(""" ::
        """      name, scalaVersion""" ::
        """    )""" ::
        """  }""" ::
        """  val toMap: Map[String, scala.Any] = Map[String, scala.Any](""" ::
        """    "name" -> name,""" ::
        """    "scalaVersion" -> scalaVersion)""" ::
        """""" ::
        """  private def quote(x: scala.Any): String = "\"" + x + "\""""" ::
        """  private def toJsonValue[T <: Matchable](value: T): String = {""" ::
        """    value match {""" ::
        """      case elem: scala.collection.Seq[? <: Matchable] => elem.map(toJsonValue).mkString("[", ",", "]")""" ::
        """      case elem: scala.Option[? <: Matchable] => elem.map(toJsonValue).getOrElse("null")""" ::
        """      case elem: scala.collection.Map[?, ? <: Matchable] => elem.map {""" ::
        """        case (k, v) => toJsonValue(k.toString) + ":" + toJsonValue(v)""" ::
        """      }.mkString("{", ", ", "}")""" ::
        """      case d: scala.Double => d.toString""" ::
        """      case f: scala.Float => f.toString""" ::
        """      case l: scala.Long => l.toString""" ::
        """      case i: scala.Int => i.toString""" ::
        """      case s: scala.Short => s.toString""" ::
        """      case bool: scala.Boolean => bool.toString""" ::
        """      case str: String => quote(str)""" ::
        """      case other => quote(other.toString)""" ::
        """    }""" ::
        """  }""" ::
        """""" ::
        """  val toJson: String = toJsonValue(toMap)""" ::
        """}""" ::
        """// $COVERAGE-ON$""" ::
        Nil
      lines match {
        case Expected => ()
        case _ =>
          (lines, Expected).zipped.toList.foreach { case (a, b) =>
            if (a != b) {
              println("- " + a)
            }
          }
          sys.error("unexpected output: \n" + lines.mkString("\n"))
      }
      ()
    }
  )
